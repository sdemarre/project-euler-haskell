;;;; euler329.lisp

(in-package #:euler329)

;;; "euler329" goes here. Hacks and glory await!

(defun generate-limited-paths (depth left-limit right-limit start-position)
  (if (= depth 1)
      (list (list start-position))
      (flet ((left-extensions ()
	       (mapcar #'(lambda (path) (cons start-position path))
		       (generate-limited-paths (1- depth) left-limit right-limit (1- start-position))))
	     (right-extensions ()
	       (mapcar #'(lambda (path) (cons start-position path))
		       (generate-limited-paths (1- depth) left-limit right-limit (1+ start-position)))))
       (cond ((= start-position left-limit) (right-extensions))
	     ((= start-position right-limit) (left-extensions))
	     (t (append (left-extensions) (right-extensions)))))))

(defun primep (n)
  (cond ((member n '(0 1)) nil)
	((member n '(2 3)) t)
	((zerop (mod n 2)) nil)
	(t (not (some #'(lambda (i) (zerop (mod n i))) (iter (for i from 3 to (isqrt n) by 2) (collect i)))))))
(defun make-prime-array (limit)
  (let ((result (make-array (list (1+ limit)) :initial-element nil)))
    (iter (for i from 0 to limit)
	  (setf (aref result i) (primep i)))
    result))
(defun problem329 (heard-string)
  (let ((prime-array (make-prime-array 500)))
    (labels ((primep (n) (aref prime-array n))
	     (probability-for-path (path)
	       (iter (for croak in-vector heard-string)
		     (for idx from 0)
		     (for position in path)
		     (multiply (+ (primep position))))
	       0)
	     (probability-for-paths-from (i)
	       (let ((paths (generate-limited-paths (length heard-string) 1 500 i)))
		 (/ (iter (for path in paths)
			  (summing (probability-for-path path))) (length paths)))))      
      (iter (for i from 1 to 500)
	    (summing (probability-for-paths-from i))))))

(defun make-random-path (boxsize path-length)
  (let ((currentpos (1+ (random boxsize)))
	(result (make-array (list path-length) :fill-pointer 0)))
    (iter (repeat path-length)
	  (vector-push currentpos result)
	  (setf currentpos (cond ((= currentpos 1) 2)
				 ((= currentpos boxsize) (1- boxsize))
				 (t (if (zerop (random 2)) (1- currentpos) (1+ currentpos))))))
    result))
(defun walk-path (path prime-array)
  (flet ((primep (pos) (aref prime-array pos)))
    (let ((result (make-array (list (length path)) :fill-pointer 0 :element-type 'character)))
     (iter (for pos in-vector path)
	   (let ((croak (if (primep pos)
			    (if (= (random 3) 0) #\N #\P)
			    (if (= (random 3) 0) #\P #\N))))
	     (vector-push croak result)))
     result)))
(defun experiment-329 (boxsize count pathlength)
  (let ((result (make-hash-table :test #'equalp))
	(prime-array (make-prime-array boxsize)))
    (dotimes (i count)
      (incf (gethash (walk-path (make-random-path boxsize pathlength) prime-array) result 0)))
    result))


(defun float-hash-values (h)
  (let ((hash-sum (iter (for (key value) in-hashtable h) (summing value))))
    (iter (for (key value) in-hashtable h)
	  (setf (gethash key h) (/ (gethash key h) hash-sum 1.0d0)))
    h))


(defun read-from-file (filename)
  (with-open-file (s filename :direction :input)
	    (let ((input (read s))
		  (result (make-hash-table :test #'equalp)))
	      (iter (for (key . value) in input)
		    (setf (gethash (symbol-name key) result) value))
	      result)))

(defun save-to-file (h filename)
  (with-open-file (s filename :direction :output :if-exists :supersede)
	    (format s "~a" (iter (for (key value) in-hashtable h)
				 (collect (cons key value))))))

(defun p329step (croak current prime-array)
  (let ((result (make-array (list (length current)))))
    (flet ((croak-prob (position)
	     (if (or (and (char= croak #\P) (aref prime-array position))
		     (and (char= croak #\N) (not (aref prime-array position))))
		 2/3
		 1/3)))
      (setf (aref result 0) (* (croak-prob 1) (aref current 1)))
      (setf (aref result (1- (length current))) (* (croak-prob (length current)) (aref current (- (length current) 2))))
      (iter (for i from 1 to (- (length current) 2))
	    (setf (aref result i) (* 1/2 (croak-prob (1+ i)) (+ (aref current (1- i)) (aref current (1+ i)))))))
    result))

(defun new-p329 (boxsize heardstring)
  (let ((prime-array (make-prime-array boxsize))
	(current (make-array (list boxsize) :initial-element 1)))
    (iter (for croak in-vector (reverse heardstring))
	  (setf current (p329step croak current prime-array)))
    (/ (reduce #'+ current) boxsize)))

(defun to-pn-string (width n)
  (labels ((to-pn-string-rec (n width l)
	     (if (zerop width)
		 l
		 (to-pn-string-rec (floor n 2) (1- width) (cons (if (zerop (mod n 2)) #\P #\N) l)))))
    (coerce (to-pn-string-rec n width nil) 'string)))

(defun all-pn-strings (width)
  (iter (for i from 0 to (1- (expt 2 width)))
	(collect (to-pn-string width i))))

(defun merge-hashtables (hashtables)
  (let ((result (make-hash-table :test #'equalp)))
    (iter (for h in hashtables)
	  (iter (for (k v) in-hashtable h)
		(incf (gethash k result 0) v)))
    result))
(defun parallel-experiment (boxsize count pathlength threadcount)
  (let ((threads (iter (for i from 1 to threadcount)
		       (collect (sb-thread:make-thread #'(lambda () (experiment-329 boxsize count pathlength)))))))
    (merge-hashtables (mapcar #'sb-thread:join-thread threads))))

(defun count-events (h)
  (iter (for (k v) in-hashtable h)
	(summing v)))

(defun compare-tables (h1 h2)
  (let ((events1 (count-events h1))
	(events2 (count-events h2)))
    (alexandria:alist-hash-table
     (iter (for (k v) in-hashtable h1)
	   (collect (cons k (/ (/ (gethash k h1) events1) (/ (gethash k h2) events2) 1.0d0))))
     :test 'equalp)))

(defun table-max (h)
  (iter (for (k v) in-hashtable h)
	(maximize v)))

(defun table-min (h)
  (iter (for (k v) in-hashtable h)
	(minimize v)))

(defun exact-329 (boxsize pathlength)
  (alist-hash-table (iter (for p in (all-pn-strings pathlength))
			  (collect (cons p (new-p329 boxsize p))))
		    :test 'equalp))

(defun compare-algorithms (boxsize pathlength exp-count)
  (let ((compare (compare-tables (exact-329 boxsize pathlength) (experiment-329 boxsize exp-count pathlength))))
    (cons (table-min compare) (table-max compare))))
