;;;; euler329.lisp

(in-package #:euler329)

;;; "euler329" goes here. Hacks and glory await!

(defun generate-limited-paths (depth left-limit right-limit start-position)
  (if (= depth 1)
      (list (list start-position))
      (flet ((left-extensions ()
	       (mapcar #'(lambda (path) (cons start-position path))
		       (generate-limited-paths (1- depth) left-limit right-limit (1- start-position))))
	     (right-extensions ()
	       (mapcar #'(lambda (path) (cons start-position path))
		       (generate-limited-paths (1- depth) left-limit right-limit (1+ start-position)))))
       (cond ((= start-position left-limit) (right-extensions))
	     ((= start-position right-limit) (left-extensions))
	     (t (append (left-extensions) (right-extensions)))))))

(defun primep (n)
  (cond ((member n '(0 1)) nil)
	((member n '(2 3)) t)
	((zerop (mod n 2)) nil)
	(t (not (some #'(lambda (i) (zerop (mod n i))) (iter (for i from 3 to (isqrt n) by 2) (collect i)))))))
(defun make-prime-array (limit)
  (let ((result (make-array (list (1+ limit)) :initial-element nil)))
    (iter (for i from 0 to limit)
	  (setf (aref result i) (primep i)))
    result))
(defun problem329 (heard-string)
  (let ((prime-array (make-prime-array 500)))
    (labels ((primep (n) (aref prime-array n))
	     (probability-for-path (path)
	       (iter (for croak in-vector heard-string)
		     (for idx from 0)
		     (for position in path)
		     (multiply (+ (primep position))))
	       0)
	     (probability-for-paths-from (i)
	       (let ((paths (generate-limited-paths (length heard-string) 1 500 i)))
		 (/ (iter (for path in paths)
			  (summing (probability-for-path path))) (length paths)))))      
      (iter (for i from 1 to 500)
	    (summing (probability-for-paths-from i))))))

(defun make-random-path (boxsize path-length)
  (let ((currentpos (1+ (random boxsize)))
	(result (make-array (list path-length) :fill-pointer 0)))
    (iter (repeat path-length)
	  (vector-push currentpos result)
	  (setf currentpos (cond ((= currentpos 1) 2)
				 ((= currentpos boxsize) (1- boxsize))
				 (t (if (zerop (random 2)) (1- currentpos) (1+ currentpos))))))
    result))
(defun walk-path (path prime-array)
  (flet ((primep (pos) (aref prime-array pos)))
    (let ((result (make-array (list (length path)) :fill-pointer 0 :element-type 'character)))
     (iter (for pos in-vector path)
	   (let ((croak (if (primep pos)
			    (if (= (random 3) 0) #\N #\P)
			    (if (= (random 3) 0) #\P #\N))))
	     (vector-push croak result)))
     result)))
(defun experiment-329 (boxsize count pathlength)
  (let ((result (make-hash-table :test #'equalp))
	(prime-array (make-prime-array boxsize)))
    (dotimes (i count)
      (incf (gethash (walk-path (make-random-path boxsize pathlength) prime-array) result 0)))
    result))


(defun float-hash-values (h)
  (let ((hash-sum (iter (for (key value) in-hashtable h) (summing value))))
    (iter (for (key value) in-hashtable h)
	  (setf (gethash key h) (/ (gethash key h) hash-sum 1.0d0)))
    h))


(defun read-from-file (filename)
  (with-open-file (s filename :direction :input)
	    (let ((input (read s))
		  (result (make-hash-table :test #'equalp)))
	      (iter (for (key . value) in input)
		    (setf (gethash (symbol-name key) result) value))
	      result)))

(defun save-to-file (h filename)
  (with-open-file (s filename :direction :output :if-exists :supersede)
	    (format s "~a" (iter (for (key value) in-hashtable h)
				 (collect (cons key value))))))
